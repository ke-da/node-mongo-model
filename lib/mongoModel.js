// Generated by CoffeeScript 1.7.1
var Mongo, MongoModel, Promise,
  __hasProp = {}.hasOwnProperty,
  __slice = [].slice;

Promise = require('bluebird');

Mongo = require("mongodb");

MongoModel = (function() {
  MongoModel.prototype.db = null;

  MongoModel.prototype.collections = {};


  /* Public */

  MongoModel.setDb = function(db) {
    return this.prototype.db = db;
  };

  MongoModel.Init = function(param) {
    if (!param.db) {
      throw new Error("Invalid db param");
    }
    return this.Connect(param.db).then((function(_this) {
      return function(db) {
        return _this.setDb(db);
      };
    })(this));
  };

  MongoModel.Connect = function(dbPath, dbOpt) {
    var mongoClient, mongoConnect;
    mongoClient = Mongo.MongoClient;
    mongoConnect = Promise.promisify(mongoClient.connect, mongoClient);
    return (mongoConnect(dbPath, dbOpt)).then(Promise.promisifyAll);
  };

  function MongoModel(param) {
    var k, v;
    for (k in param) {
      if (!__hasProp.call(param, k)) continue;
      v = param[k];
      this[k] = v;
    }
    this.data = null;
  }

  MongoModel.prototype.setDb = function(db) {
    this.collections = {};
    this.db = db;
    return this;
  };

  MongoModel.prototype.setCollectionName = function(collectionName) {
    this.collectionName = collectionName != null ? collectionName : colName;
    return this;
  };

  MongoModel.prototype.getCollection = function(colName) {
    var promise;
    if (colName == null) {
      colName = this.collectionName;
    }
    if (this.collections[colName] == null) {
      promise = this.db.createCollectionAsync(colName).then(Promise.promisifyAll).then((function(_this) {
        return function(col) {
          if (colName === _this.collectionName && _this.dbIndex) {
            return _this.ensureIndex(col, _this.dbIndex).then(function() {
              return col;
            });
          } else {
            return _this.collections[colName] = col;
          }
        };
      })(this));
      this.collections[colName] = promise;
      return promise;
    } else if (this.collections[colName] instanceof Promise) {
      return this.collections[colName];
    } else {
      return Promise.resolve(this.collections[colName]);
    }
  };

  MongoModel.prototype.ensureIndex = function(col, index, indexOpt) {
    var argvs, i, promises, _i, _len;
    if (indexOpt == null) {
      indexOpt = {};
    }
    if (Array.isArray(index)) {
      promises = [];
      for (_i = 0, _len = index.length; _i < _len; _i++) {
        i = index[_i];
        argvs = Array.isArray(i) ? [col].concat(i) : [col, i];
        promises.push(this.ensureIndex.apply(this, argvs));
      }
      return Promise.all(promises);
    } else {
      return col.ensureIndexAsync(index, indexOpt);
    }
  };

  MongoModel.prototype.insert = function(row) {
    var isBatch;
    isBatch = Array.isArray(row);
    return this.getCollection().then(function(col) {
      var p;
      p = col.insertAsync(row);
      if (isBatch) {
        return p;
      }
      if (!isBatch) {
        return p.then(function(rows) {
          row = rows[0];
          return row;
        });
      }
    });
  };

  MongoModel.prototype.update = function(query, update, opt) {
    if (opt == null) {
      opt = {};
    }
    return this.getCollection().then(function(col) {
      return col.updateAsync(query, update, opt);
    });
  };

  MongoModel.prototype.upsertBy = function(key, row) {
    return Promise["try"]((function(_this) {
      return function() {
        if (row[key] == null) {
          throw new Error("Invalid upsert");
        }
        return _this.getCollection().then(function(col) {
          var k, query, rowCopy, v;
          query = {};
          query[key] = row[key];
          rowCopy = {};
          for (k in row) {
            if (!__hasProp.call(row, k)) continue;
            v = row[k];
            if (k !== "_id") {
              rowCopy[k] = v;
            }
          }
          return col.updateAsync(query, {
            $set: rowCopy
          }, {
            upsert: true
          }).then(function(_arg) {
            var cnt, info;
            cnt = _arg[0], info = _arg[1];
            return cnt;
          });
        });
      };
    })(this));
  };

  MongoModel.prototype.find = function() {
    var argv;
    argv = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.getCollection().then((function(_this) {
      return function(col) {
        return col.find.apply(col, argv);
      };
    })(this));
  };

  MongoModel.prototype.findOne = function() {
    var argv;
    argv = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.getCollection().then((function(_this) {
      return function(col) {
        return col.findOneAsync.apply(col, argv);
      };
    })(this));
  };

  MongoModel.prototype.findArray = function() {
    var argv;
    argv = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.getCollection().then((function(_this) {
      return function(col) {
        var cursor, toArray;
        cursor = col.find.apply(col, argv);
        toArray = Promise.promisify(cursor.toArray, cursor);
        return toArray();
      };
    })(this));
  };

  MongoModel.prototype.remove = function(query, justOne) {
    return this.getCollection().then(function(col) {
      return col.removeAsync(query, justOne);
    });
  };

  MongoModel.prototype.distinct = function(key, query, opt) {
    return this.getCollection().then(function(col) {
      return col.distinctAsync(key, query, opt);
    });
  };

  return MongoModel;

})();

module.exports = MongoModel;
